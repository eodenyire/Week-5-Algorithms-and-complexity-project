# -*- coding: utf-8 -*-
"""Week 5 Project Notebook: Algorithms and Complexity- Emmanuel Anyira

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fdINhMTCXIoicL6bw22bkLAo7SZHIPJU

# Project Notebook: Algorithms and Complexity

## 1. Defining the Question

In this project, we put everything together we've learnt about algorithms complexity. We will imagine that we own an online laptop store and want to build a way to answer a few different business questions about our inventory.

We will use the laptops.csv (https://bit.ly/3G32iYj) file as our inventory.

* **ID**: A unique identifier for the laptop.
* **Company**: The name of the company that produces the laptop.
* **Product**: The name of the laptop.
* **TypeName**: The type of laptop.
* **Inches**: The size of the screen in inches.
* **ScreenResolution**: The resolution of the screen.
* **CPU**: The laptop CPU.
* **RAM**: The amount of RAM in the laptop.
* **Memory**: The size of the hard drive.
* **GPU**: The graphics card name.
* **OpSys**: The name of the operating system.
* **Weight**: The laptop weight.
* **Price**: The price of the laptop.

Let's explore the data and print the first few rows before we start implementing a way to represent this data as the store inventory.

**Pre-requisite Tasks**

* Import the csv module.
* Read the laptops.csv file using the `csv` module.
* Assign the first row to a variable named header.
* Assign the remaining rows to a variable named rows.
* Print the value of header.
* Print the first five rows in rows.
"""

# Import the csv module
import csv

# Read the laptops.csv file
with open('laptops.csv', encoding = "ISO-8859-1") as f:
    reader = csv.reader(f)
    rows = list(reader)
    header = rows[0]
    rows = rows[1:]
    
print(header)
for i in range(5):
    print(rows[i])

"""## 2. Inventory Class

The goal of this project is to create a class that represents our inventory. The methods in that class will implement the queries that we want to answer about our inventory. We will also preprocess that data to make those queries run faster.

Here are some queries that we will want to answer:

* Given a laptop id, find the corresponding data.
* Given an amount of money, find whether there are two laptops whose total price is that given amount.
* Identify all laptops whose price falls within a given budget.
* Let's start by implementing the constructor. It will take the name of the CSV file as argument and then read the rows contained in it. You can use the code from the previous screen to do so.

Let's refresh our memories on how to create a class.

We can create a Python class named SomeName that has two arguments `argument1`, `argument2` using the following syntax:

```
class SomeName():

    def __init__(self, argument1, argument2):
        self.argument1 = argument1
        self.argument2 = argument2
```

The `self` parameter is a default parameter that is always passed to any method of the class. It contains a reference to the class itself and can be used to store values. In this case, we store the values of the two provided arguments.

**Tasks**

* Create a class named Inventory.
* Define the constructor (__init__() method) with two arguments: self and csv_filename.
* Read the CSV file provided in csv_filename. We will assume that the encoding is UTF-8, so you don't need to worry about it.
* Assign the first row to self.header and the remaining rows to self.rows.
Convert the price of each row to an integer. The price is the last column.
* Test your class by creating an instance of Inventory using 'laptops.csv' as argument.
* Print the headers by printing the value of the header property.
* Using the len() function, print the number of rows. You should have 1303 rows.
"""

# Challenge 
# ---
#
class Inventory():                    # step 1
    
    def __init__(self, csv_filename): # step 2
        with open(csv_filename, encoding = "ISO-8859-1") as f: # step 3
            reader = csv.reader(f)
            rows = list(reader)
        self.header = rows[0]         # step 4
        self.rows = rows[1:]
        for row in self.rows:         # step 5
            row[-1] = int(float(row[-1]))

# your code goes here

inventory = Inventory('laptops.csv')
print(inventory.header)
print(len(inventory.rows))

"""## 3. Finding a Laptop From the Id

Throughout this project, we will ask you to make several improvements to the Inventory class. We suggest that you create a new cell at the start of each screen and copy and paste the last version of the class and modify the later. This will help you keep track of the changes that you make.

The first thing that we will implement is a way to look up a laptop from a given identifier. In this way, when a customer comes to our store with a purchase slip, we can quickly identify the laptop to which it corresponds.

**laptop id search**

For this, we will write a function named `get_laptop_from_id()`. This function will take as argument the identifier of the laptop and return the full row of the laptop with that id.


**Tasks**

* Inside the Inventory class, create a method `get_laptop_from_id()` with two arguments: self and laptop_id.
* Using a `for` loop over `self.rows`, identify if there is a row with whose laptop id is the same as laptop_id.
* Return that row if it was found or None if no laptop has the given identifier.
* Test your class by creating an instance of Inventory using `'laptops.csv'` as argument.
* Call `get_laptop_from_id()` by giving '3362737' as argument and print the result. It should find a matching laptop.
* Call `get_laptop_from_id()` by giving '3362736' as argument and print the result. It should not find a laptop.
"""

# Challenge 
# ---
# 
import csv

class Inventory():                    

    def __init__(self, csv_filename):
        with open(csv_filename,encoding = "ISO-8859-1") as f: 
            reader = csv.reader(f)
            rows = list(reader)
        self.header = rows[0]        
        self.rows = rows[1:]
        for row in self.rows:              
            row[-1] = int(float(row[-1]))
            
    def get_laptop_from_id(self, laptop_id):
        """Gets the row with the given laptop ID from the inventory.

        Parameters:
        laptop_id (str): The ID of the laptop to search for.

        Returns:
        list: A list of values representing the row with the matching ID,
              or None if no matching ID is found.
        """
        for row in self.rows:
            if row[0] == laptop_id:
                return row
        return None

Results = Inventory('laptops.csv')
print(Results.get_laptop_from_id('3362737'))
print(Results.get_laptop_from_id('3362736'))

"""Observations:- For both two laptop ids provided, I have not found matching laptops

## 4. Improving Id Lookups

The algorithm we've created requires us to look at every single row to find the one that we are looking for (or decide that such a row does not exist). This algorithm has time complexity O(R) where R is the number of rows.

We've learned, that we can solve this problem more efficiently by preprocessing the data. Using a set, we can check in constant time whether a given identifier exists. However, we don't just want to know if it exists, we also want to retrieve the remaining row information. Therefore, we will use a dictionary instead of a set. Dictionaries have the same fast lookup properties that sets have, but allow us to associate values to the keys.

In our dataset, we only have about 1,300 laptops, so it might seem unnecessary to improve the performance of this query. However, you have to imagine that this code could be used in situations where the inventory contains millions of rows. Also, if we perform a lot of queries, even on a small dataset, the slow query performance will start to add up. It might eventually become the bottleneck of the application.

The idea is proceprocess the data into a dictionary where the keys are the IDs and the values the rows. Then, we will use that dictionary in the `get_laptop_from_id()` method. We can do this by:

* Preprocess the data and create the dictionary in the `__init__()` method.
* Re-implement the get_laptop_from_id() method. We will do it as a new method so that we can compare the two.


**Tasks** 

* At the end of the `__init__()` method, assign an empty dictionary to self.id_to_row.
* Loop over all rows and assign that row to the dictionary. Use the row id (the first element in a row) as the key and the whole row as the value.
* Create a new method named `get_laptop_from_id_fast()` with arguments: self and laptop_id.
* Implemented it by:
Checking whether the given id is in self.id_to_row.
* If it is, then return the corresponding row. Otherwise, return None.
* Test your class by creating an instance of Inventory using 'laptops.csv' as argument.
* Call `get_laptop_from_id_fast()` by giving '3362737' as argument and print the result. It should find a matching laptop.
Call `get_laptop_from_id_fast()` by giving `'3362736'` as argument and print the result. It should not find a laptop.
"""

# Your code goes here

import csv

class Inventory():
    """
    A class that represents an inventory of laptops.
    """
    
    def __init__(self, csv_filename):
        """
        Initializes an Inventory object by reading the laptop data from a CSV file.
        
        Parameters:
        csv_filename (str): The name of the CSV file containing the laptop data.
        """
        with open(csv_filename, encoding = "ISO-8859-1") as f: 
            reader = csv.reader(f)
            rows = list(reader)
        self.header = rows[0]        
        self.rows = rows[1:]
        for row in self.rows:              
            row[-1] = int(float(row[-1]))
        
        self.id_to_row = {}
        for row in self.rows:
            self.id_to_row[row[0]] = row
            
    def get_laptop_from_id(self, laptop_id):   # step 1
    # your code goes here
      for row in self.rows:
        if row[0] == laptop_id:
          return row
      return None

    def get_laptop_from_id_fast(self, laptop_id):
      if laptop_id in self.id_to_row:
          return self.id_to_row.values()
      return None


inventory_match = Inventory('laptops.csv')
print(inventory_match.get_laptop_from_id('3362737')) 
print(inventory_match.get_laptop_from_id('3362736'))

"""Observation: No matching laptops for the laptop ids provided

## 5. Comparing the Performance

The `get_laptop_from_id()` method has time complexity O(R) where R is the number of rows. In contrast, the new implementation as time complexity O(1). It does so by using more memory to store the self.`id_to_row` dictionary and using a bit more time creating an instance (because it needs to create the dictionary).

Let's experiment to compare the performance of the two methods. The idea is to generate random IDs using the random module. Then, use both methods to lookup these same IDs. We will use the time module to measure the execution time of each lookup and, for each method, add all times together.

Recall that we can measure the execution of a function `func()` as follows:

```
import time
start = time.time()
func()
end = time.time()
elapsed = end - start
```

To generate a list of N random values between a and b using the random module like so:
```
import random
values = [random.randint(a, b) for _ in range N]
```

**Tasks**

* Import the `time` module.
* Import the `random` module.
* Generate a list named `ids` with 10,000 random values between "1000000" and "9999999" (this is the id range). Note the use of strings rather than integers. This is because the IDs in the CSV files are read a strings, not integers. You can generate these by generating integers and converting them to strings using the str() function.

* Create an instance of Inventory by giving `'laptops.csv'` as argument.
Initialize a variable named `total_time_no_dict` and set it to 0. This variable will aggregate the times of calling get_laptop_from_id().

* For each identifier in ids do:
    a) Assign the value of time.time() to a variable named start.
    b) Call the get_laptop_from_id() function on the current identifier.
    c) Assign the value of time.time() to a variable named end.
	d) Add the elapsed time, end - start, to total_time_no_dict.

* Initialize a variable named `total_time_dict` and set it to 0. This variable will aggregate the times of calling get_laptop_from_id_fast().
For each identifier in ids do:
	a) Assign the value of time.time() to a variable named start.
	b) Call the get_laptop_from_id_fast() function on the current identifier.
	c) Assign the value of time.time() to a variable named end.
	d) Add the elapsed time, end - start, to total_time_dict.

* Print the values of `total_time_no_dict` and `total_time_dict`.
"""

# Your code goes here

import time
import random

# Create a list of 10,000 random laptop IDs
ids = str([random.randint(1000000, 9999999) for _ in range(10000)])

# Create an instance of the Inventory class using 'laptops.csv' file
inventory_time = Inventory('laptops.csv')

# Test the performance of the get_laptop_from_id() method without dictionary preprocessing
total_time_no_dict = 0
for id in ids:
  start = time.time()
  inventory_time.get_laptop_from_id(id)
  end = time.time()
  total_time_no_dict += (end - start)

# Test the performance of the get_laptop_from_id_fast() method with dictionary preprocessing
total_time_dict = 0
for id in ids:
  start = time.time()
  inventory_time.get_laptop_from_id_fast(id)
  end = time.time()
  total_time_dict += (end - start)

# Print the total time taken for each method
print(f' Time taken with Dict : {total_time_dict} Seconds')
print(f'Time taken no Dict :{total_time_no_dict} Seconds')

"""## 6. Two Laptop Promotion

Sometimes, your store offers a promotion where you give a gift card. A customer can use the gift to buy up to two laptops. To avoid having to keep track of what was already spent, the gift card has a single time usage. This means that, even if there is leftover money, it cannot be used anymore.

For example, imagine that there are only three laptops in inventory. The prices of these laptops are $1,339, $898, and $575.

Say we offered a gift card of $2,500. 

Since a customer can buy, at most, two laptops with a gift card, the maximum they can spend is $2,237 ($1,339 plus $898).

Therefore, they might feel cheated because, no matter how they spend their gift card, they cannot spend the full $2,500.

You don't want to make a customer feel cheated, so whenever you issue a gift card, you want to make sure that there is at least one way to spend it in full. In other words, before issuing a gift card for D dollars, you want to make sure that either there is a laptop that costs exactly D dollars or two laptops whose costs add up to precisely D dollars.

Write a function that, given a dollar amount, checks whether it is possible to spend precisely that amount by purchasing up to two laptops.

**Tasks** 

* Create a method named `check_promotion_dollars()` that takes two arguments: self and dollars.
* Loop over all rows to check if there exists a laptop whose price is exactly dollars. Return True if you find one.
* Using a double for loop, iterate over all pairs of rows (not necessarily distinct because we can buy the same laptop twice) and check if there is a pair whose prices adds up to exactly dollars. Return True if you find one.
* At the end of the function, return `False` to indicate that it is impossible to spend exactly dollars by purchasing at most two laptops.
* Test your class by creating an instance of Inventory by giving `'laptops.csv'` as argument.
* Call `check_promotion_dollars()` by giving 1000 as argument and print the result. It should find a solution.
* Call `check_promotion_dollars()` by giving 442 as argument and print the result. It should not find a solution.
"""

# Your code goes here

class Inventory():
    """
    A class representing an inventory of laptops.
    
    Attributes:
    -----------
    header : list
        The list containing header of the inventory data.
    rows : list
        The list containing rows of the inventory data.
    id_to_row : dict
        The dictionary containing laptop IDs as keys and row data as values.
        
    Methods:
    --------
    __init__(csv_filename: str) -> None
        Initializes the Inventory object with inventory data from the given CSV file.
    get_laptop_from_id(laptop_id: str) -> list or None
        Finds and returns the row of the laptop with the given ID.
    get_laptop_from_id_fast(laptop_id: str) -> list or None
        Finds and returns the row of the laptop with the given ID using a preprocessed dictionary.
    check_promotion_dollars(dollars: int) -> bool
        Checks whether there is a laptop that costs exactly the given number of dollars
        or a combination of two laptops that costs exactly the given number of dollars.
    """                    
    
    def __init__(self, csv_filename):
        with open(csv_filename, encoding = "ISO-8859-1") as f: 
            reader = csv.reader(f)
            rows = list(reader)
        self.header = rows[0]        
        self.rows = rows[1:]
        for row in self.rows:              
            row[-1] = int(float(row[-1]))
        self.id_to_row = {}
        for row in self.rows: 
          self.id_to_row.update({row[0]:row})
            
    def get_laptop_from_id(self, laptop_id):   # step 1
      for row in self.rows:
        if row[0] == laptop_id:
          return row
      return None
    
    def get_laptop_from_id_fast(self, laptop_id):
      if laptop_id in self.id_to_row:
          return self.id_to_row.values()
      return None
    def check_promotion_dollars(self, dollars):
      for row in self.rows:
        if row[-1] == dollars:
          return True
        for row1 in self.rows:
          if row[-1] + row1[-1]== dollars:
            return True
      return False
    
inventory_promo = Inventory('laptops.csv')
print(inventory_promo.check_promotion_dollars(1000))
print(inventory_promo.check_promotion_dollars(442))

"""## 7. Optimizing Laptop Promotion

We've learned how we can preprocess data to answer the kind of queries that we used in the `check_promotion_dollars()`. Let's implement this to make our code run faster.

Since we only care about whether or not there is a solution, we can store all laptops prices in a set when we initialize the inventory. Then we can check in constant time whether there is a laptop with a given price.

To check if there is a pair of laptops can be done in the same way as we've learned in the last lesson.


**Tasks**
* At the end of the `__init__()` method, assign an empty set to self.prices.
* Loop over all rows and add the price contained in that row to `self.prices`.
* Create a method named `check_promotion_dollars_fast()` that takes two arguments: self and dollars.
* Use the `self.prices` set to check whether there is a laptop whose cost is exactly dollars. Return `True` if it is the case.
* Using the technique we've learned in the previous lesson to check whether two values in `self.prices` add up to exactly dollar. Return `True` if it is the case.
* At the end of the function, return False to indicate that it is impossible to spend exactly dollars by purchasing at most two laptops.
* Test your class by creating an instance of Inventory by giving `'laptops.csv'` as argument.
* Call `check_promotion_dollars_fast()` by giving 1000 as argument and print the result. It should find a solution.
* Call `check_promotion_dollars_fast()` by giving 442 as argument and print the result. It should not find a solution.
"""

# Your code goes here
class Inventory():
    """Class for inventory management of laptops.

    Attributes:
        header (list): List of column headers.
        rows (list): List of rows containing laptop information.
        id_to_row (dict): Dictionary mapping laptop ids to rows.
        prices (set): Set of laptop prices.

    """                    
    def __init__(self, csv_filename):
        with open(csv_filename, encoding = "ISO-8859-1") as f: 
            reader = csv.reader(f)
            rows = list(reader)
        self.header = rows[0]        
        self.rows = rows[1:]
        for row in self.rows:              
            row[-1] = int(float(row[-1]))
        self.id_to_row = {}
        for row in self.rows: 
          self.id_to_row.update({row[0]:row})

        self.prices = set()
        for row in self.rows: 
          self.prices.add(row[-1])
            
    def get_laptop_from_id(self, laptop_id):
  
      for row in self.rows:
        if row[0] == laptop_id:
          return row
      return None
    
    def get_laptop_from_id_fast(self, laptop_id):
      if laptop_id in self.id_to_row:
          return self.id_to_row.values()
      return None

    def check_promotion_dollars(self, dollars):
      for row in self.rows:
        if row[-1] == dollars:
          return True
        for row1 in self.rows:
          if row[-1] + row1[-1]== dollars:
            return True
      return False

    def check_promotion_dollars_fast(self, dollars):
      if dollars in self.prices: 
        return True
      for row in self.rows:
        if  dollars-row[-1] in self.prices:
          return True
      return False

optimised_promo = Inventory('laptops.csv')
print(optimised_promo.check_promotion_dollars_fast(1000))
print(optimised_promo.check_promotion_dollars_fast(442))

"""## 8. Comparing Promotion Functions

Let's compare the performance of the last two functions that we wrote.

* Generate a list named `prices` with 100 random values between 100 and 5,000.
* Create an instance of `Inventory` by giving `'laptops.csv'` as argument.
* Initialize a variable named `total_time_no_set` and set it to 0. This variable will aggregate the times of calling `check_promotion_dollars()`.
* For each value in the prices do:
    a) Assign the value of `time.time()` to a variable named `start`.
    b) Call the `check_promotion_dollars()` function on the current price.
    c) Assign the value of `time.time()` to a variable named `end`.
    d) Add the elapsed time, end - start, to `total_time_no_set`.
* Initialize a variable named `total_time_set` and set it to `0`. This variable will aggregate the times of calling `check_promotion_dollars_fast()`.
* For each value in the prices do:
	a) Assign the value of time.time() to a variable named start.
	b) Call the check_promotion_dollars_fast() function on the current price.
	c) Assign the value of `time.time()` to a variable named end.
	d) Add the elapsed time, end - start, to `total_time_set`.
* Print the values of `total_time_no_set` and `total_time_set`.
"""

# Your code goes below
prices = [random.randint(100, 5000) for _ in range(100)]
"""
A program that compares the time it takes to perform the check_promotion_dollars() method
on an instance of the Inventory class with and without a set of unique prices.

Attributes:
- prices (list of int): A list of 100 random integers between 100 and 5000.
- compare_promo (Inventory object): An instance of the Inventory class that represents the inventory
  of laptops stored in 'laptops.csv'.
- total_time_no_set (float): The total time taken to execute the check_promotion_dollars() method
  without using a set of unique prices.
- total_time_set (float): The total time taken to execute the check_promotion_dollars_fast() method
  that uses a set of unique prices.

Methods:
- check_promotion_dollars(dollars) -> bool:
  Given a dollar value, checks whether there are one or two laptops whose prices add up to that dollar
  value in the inventory. Returns True if such laptops exist, otherwise returns False.
- check_promotion_dollars_fast(dollars) -> bool:
  Given a dollar value, checks whether there are one or two laptops whose prices add up to that dollar
  value in the inventory. Returns True if such laptops exist, otherwise returns False.
  This method uses a set of unique prices in the inventory to perform the check.

Usage:
- To use this program, create an instance of the Inventory class with the name of the CSV file that
  contains the inventory data, and run the program.

Example:
  prices = [random.randint(100, 5000) for _ in range(100)]
  compare_promo = Inventory('laptops.csv')
  total_time_no_set = 0
  for price in prices:
    start = time.time()
    compare_promo.check_promotion_dollars(price)
    end = time.time()
    total_time_no_set += (end - start)

  total_time_set = 0
  for price in prices:
    start = time.time()
    compare_promo.check_promotion_dollars_fast(price)
    end = time.time()
    total_time_set += (end - start)

  print(f'total_time_no_set {total_time_no_set}\ntotal_time_set {total_time_set}')
"""

compare_promo = Inventory('laptops.csv')
total_time_no_set = 0
for price in prices:
  start = time.time()
  compare_promo.check_promotion_dollars(price)
  end = time.time()
  total_time_no_set += (end - start)


total_time_set = 0
for price in prices:
  start = time.time()
  compare_promo.check_promotion_dollars_fast(price)
  end = time.time()
  total_time_set += (end - start)

print(f'total_time_no_set :{total_time_no_set} Seconds')      
print(f'total_time_set :{total_time_set} Seconds')

"""## 9. Conclusion

Congratulations on implementing a class to represent the inventory of a laptop shop. In this project, you've learned that we can answer business questions more efficiently by preprocessing the data.


If you want to push this project further, we suggest that you think about the following queries:

* Imagine that we extend our budget query to take as input a range of prices, `min_price` and `max_price`, rather than a single price. Write a query that finds all laptops whose price is in the given range.
Sometimes, a customer wants a laptop with some characteristics such as, for instance, 8GB or RAM and a 256GB hard drive. It would be interesting for those customers to provide a way to find the cheapest laptop that matches the desired characteristics. For simplicity, focus only on the amount of RAM and hard drive capacity. You might need to convert those values to integers rather than using strings.
* In this project, we only explored three possible queries that we might want to do over the data. In general, we often have a lot of different datasets to process and queries to answer. Designing such a class for every type of data in a business and implementing specific query methods takes a lot of time
"""

import random
import time

# Step 1: Generate list of random prices
prices = [random.randint(100, 5000) for _ in range(100)]

# Step 2: Create instance of Inventory
inventory_further = Inventory('laptops.csv')

# Step 3: Measure time taken for check_promotion_dollars() for each price
total_time_no_set = 0
for price in prices:
    start = time.time()
    inventory_further.check_promotion_dollars(price)
    end = time.time()
    total_time_no_set += (end - start)

# Step 4: Measure time taken for check_promotion_dollars_fast() for each price
total_time_set = 0
for price in prices:
    start = time.time()
    inventory_further.check_promotion_dollars_fast(price)
    end = time.time()
    total_time_set += (end - start)

# Step 5: Print results
print(f"Total time taken for check_promotion_dollars(): {total_time_no_set:.6f} seconds")
print(f"Total time taken for check_promotion_dollars_fast(): {total_time_set:.6f} seconds")